<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>An intro to the CLi</title>
    <base href="https://andirko.eu">
    <meta name="description" content="">
    <meta name="author" content=''>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    
        <link rel="icon" type="image/ico" href="https://andirko.eu/favicon.svg">
    
	
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row p-0">
        <a class="navbar-brand mr-sm-auto" href="https://andirko.eu">Alejandro M. Andirk√≥</a>
        <div class="navbar-nav flex-row">
            
                
                
                    <a class="nav-item nav-link" href="/about">About</a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/cv.pdf">CV</a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/posts">Posts</a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/contact">Contact</a>
                    
                
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <h1 id="an-introduction-to-the-command-line-interface">An introduction to the Command-Line interface</h1>
<p>Too afraid to stare into the black abyss of your computer&rsquo;s <strong>terminal</strong>? Do you want to learn to use it but have no clue where to start or why should you care about tools written decades ago? Don&rsquo;t worry, we&rsquo;ve got you covered with all that serious stuff.</p>
<p>This is a <strong>beginners</strong> course  <a href="http://ptmartins.info/" target="_blank">Pedro Tiago Martins</a> and I wrote it originally for internal use in  <a href="http://cbl.ub.edu/" target="_blank">our research group</a>. It&rsquo;s intended to be completed over the course of a couple afternoons and <strong>assumes no previous knowledge</strong> of coding or experience with Unix systems.
In this course we&rsquo;ll cover:</p>
<ol>
<li>Why you using the terminal is useful</li>
<li>Basic system file manipulation</li>
<li>Some of the most common programs you can use to manipulate data, including <code>grep</code>, <code>sed</code> or <code>awk</code></li>
</ol>
<p>While we don&rsquo;t think this course is by any means exhaustive, it should at least give you a footing into the world of the terminal. The idea is that by the end of this course you should be able to start experimenting with the more complex functions of these programs.</p>
<p>Through the documment you&rsquo;ll see sometimes <strong>exercises</strong>, as this course was intended as a hands-on learning session. While you could just read the whole thing, we recommend to keep a terminal window open to follow the exercises. We also encourage you to integrate these programs in your day-to-day workflow, as that&rsquo;s the best way to learn to use them efficiently. The best way to learn is to do! Take a moment to consider how to use the information presented here.</p>
<p><strong>Disclaimer:</strong> mind that this guide might contain oversimplifications for the sake of learnability. For example, ou will find certain terms being used (sometimes) interchangeably such as <strong>terminal</strong>, <strong>bash, command line, console</strong>, or <strong>shell.</strong> Technically, these all mean different things, but for our current purposes they can indeed be used interchangeably for the most part. Once you start feeling more comfortable with the tools we list here we encourage you to check the definitions.</p>
<h1 id="first-of-all-what-is-the-terminal-exactly">First of all, what is the terminal exactly?</h1>
<p>The terminal is <strong>a text-based interface to your computer</strong>, the same way a graphical interface is. Some things are better accomplished (or only possible) through the terminal. Some things would be really tedious in a graphical user interface. The terminal can be, in general, a <strong>much faster than interacting with your computer in other ways</strong>.</p>
<p>When I started by PhD I had migrated to Linux some time ago, but I never used the terminal too much. However, now it&rsquo;s an integral part of my work (in fact, I&rsquo;m writting this in a text editor in the terminal called <code>vim</code>!), and it has facilitated many tasks over the years. Additionally, I&rsquo;m able to keep a register of everything I do, and, for example, reuse old code to repeat otherwise cumbersome tasks now. Anyone can take advantage of the terminal, but knowing how to use it is a great skill to have for anyone who works professionally with data, code or text files.</p>
<p>Here are some examples of terminal programs (but of course there are many more!)</p>
<ul>
<li><code>pandoc</code> - converts document files between formats. You can read about it  <a href="https://pandoc.org" target="_blank">here</a>.</li>
<li><code>ffmpeg</code> - converts audio or video files between formats (among other things) .You can read about it  <a href="https://www.ffmpeg.org" target="_blank">here</a>.</li>
<li><code>youtube-dl</code> - downloads videos from youtube and other platforms. You can read about it  <a href="https://ytdl-org.github.io/youtube-dl/index.html" target="_blank">here</a>.</li>
<li><code>git</code>  - In very rough terms, a version control tool.</li>
<li><code>circos</code>, to create, well, Circos plots like  <a href="http://circos.ca/images/" target="_blank">these ones</a>.</li>
<li><code>Bedtools</code> - a program to manipulate .bed files. BED files are one of the standard storage formate for many genomic features. You can read more about them  <a href="https://genome.ucsc.edu/FAQ/FAQformat.html" target="_blank">here</a>.</li>
</ul>
<h2 id="two-important-reasons-to-learn-to-use-it">Two important reasons to learn to use it</h2>
<p>Learning to use Unix shell tools and the basics of coding on the terminal has <strong>two inherent advantages</strong> that are shared with learning to code in general:</p>
<ul>
<li><strong>Automation through scripting</strong>. A script is a <strong>set of instructions</strong>. Instead of doing something manually, you can tell the computer: when I tell you, you will do this, and that, and that other thing. This might involve things that are very tedious and repetitive and would take ages to do (they might be even practically impossible!). A general rule of thumb is that if you do something more than a couple times, it might be a good idea to write a script for it. Here&rsquo;s an example:</li>
</ul>
<blockquote>
<ul>
<li>Check these 90 files</li>
<li>Delete only those that have ‚Äútest‚Äù in the name.</li>
<li>Generate a table with the names of the files, alphabetically numbered.</li>
<li>Add the number of lines of each document in the table.
Of course, nothing forces you to do this in the terminal, but imagine the ammount of time it would take, and what would happen if, for example, a collaborator tells you that the files you are using are wrong and you have to do the task again. <strong>With a script you can do this in a couple of seconds, as many times as needed</strong>.</li>
</ul>
</blockquote>
<ul>
<li><strong>Reproducibility</strong>. It‚Äôs important that all steps of any task we do as scientists (towards a publication) are reproducible. In practice, that means <strong>keeping scripts that perform the data manipulations and analyses we do</strong>. If we worked towards automating tasks, the work is virtually done. The extra few steps involve cleaning it up, making it understandable, and if possible make it versatile enough to be used with someone else‚Äôs data. On top of that, most of the programs you can use in a Unix terminal are present in other systems by default, meaning sometimes to reproduce something in a different system you only have to move there the relevant data and scripts and run them.</li>
</ul>
<p>Reproducibility is important also when are stuck with errors. If you share your code along with your problem, people will be able to reproduce the problem itself, and tell you where you need to fix it. Very often, when you google how to do something (regardless of tool), you get a solution that involves the terminal, sometimes without even mentioning it. You will start not only recognizing what the solution is about in this cases, but also apply it. For example, one time  <a href="http://ptmartins.info/" target="_blank">Pedro</a> was helping editing a book in <code>LaTeX</code>, and he asked one of the people involved how to do something. The email he got in reply to this was the following, no more, no less:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">sed -i s/.*<span style="color:#ae81ff">\\</span>emph.*// main.adx
</code></pre></div><p>One could argue that this is too short an email reply, but being acquainted with the terminal was enough to use the solution. ‚ÄùThat is a <strong>one liner</strong> - a very short program that solves a specific problem. We&rsquo;ll speak about this specific program (<code>sed</code>) later on.</p>
<h2 id="a-note-on-operating-systems">A note on operating systems</h2>
<p>The terminal is an interface readily available in UNIX-like systems. What does that mean? <strong>If you use any flavor of Linux or MacOS, you‚Äôre set</strong>. You can skip right to the next section. If you use Windows, however, this is not the case. You will need some extra stuff to be able to use it, since Windows is not a UNIX-like system. Here are some things you can do in that case:</p>
<ul>
<li>You can install a  <a href="https://www.virtualbox.org" target="_blank">virtual machine</a> on your PC and install a Linux OS there (if you are new to Linux we recommend Ubuntu)</li>
<li>You can install the  <a href="https://ubuntu.com/wsl" target="_blank">Windows Subsystem for Linux</a>, which will allow you to access a Linux Terminal on your PC.</li>
<li>You could as well get a linux installer into a USB and try a  <a href="https://ubuntu.com/tutorials/try-ubuntu-before-you-install#1-getting-started" target="_blank">live version</a>, that is, a version of Linux without installation in your computer. This is a safe way to test if Linux is your thing or no.</li>
<li>There are other options we don‚Äôt need to get into (e.g.  <a href="https://www.cygwin.com" target="_blank">cygwin</a>. However, if you are interested in that you probably should be teaching us rather than read this guide üòâ</li>
</ul>
<h1 id="enough-talk">Enough talk</h1>
<p>Let&rsquo;s get to the real work!</p>
<iframe src="https://giphy.com/embed/LmNwrBhejkK9EFP504" width="680" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/memecandy-LmNwrBhejkK9EFP504"></a></p>
<h3 id="opening-the-terminal">Opening the terminal</h3>
<p>The terminal is a program like any other. Look for it where you have other programs in your computer, and you‚Äôll find it. In most Linux distributions there is also a default shortcut that opens it: <code>ctrl + alt + t</code>. Otherwise, you can just bring up the search bar and type in ‚ÄúTerminal‚Äù.</p>
<p>You will be greeted with a prompt, waiting for commands to be typed in. Depending on your system, you will see something like the name of your computer, username and your current location in the file structure of your computer. Typically, your initial location is your home folder, which is the same as your username. It is in this folder that other, familiar folders are located in your computer (Desktop, Downloads, etc.). Indeed, you are always ‚Äúsomewhere‚Äù in your computer where you‚Äôre in the terminal.</p>
<h3 id="your-first-basic-commands">Your first basic commands</h3>
<p><strong>A command can do something on its own, or have arguments</strong> (which can be optional or mandatory).</p>
<p>An example of a command that has no arguments, that is, it‚Äôs just one term on its own, is <code>pwd</code>, which stands for ‚Äú<code>p</code>rint <code>w</code>orking <code>d</code>irectory‚Äù. Here, as in most computing tasks, printing means ‚Äúshow on the screen‚Äù, and working directory is the directory you are currently in.</p>
<blockquote>
<p><strong>Practice:</strong> <strong>Type in <code>pwd</code></strong> and press <code>Enter</code>. The result of this command will show up in the line below (in this case, <code>pwd</code> prints your current working directory).
Another command is <code>ls</code> (short for ‚Äòlist‚Äô), which lists all the files in the directory you‚Äôre in. Type in <code>ls</code> and press <code>Enter</code>, and you will see all the folders and files listed below.</p>
</blockquote>
<p>Here you will already see a change compared to your graphical interface (the way you usually navigate your computer). You will see that if a folder has too many files, your computer might become slower or even get unusable while trying to display and navigate through them all. This does not happen in the terminal.</p>
<p><strong>Now let‚Äôs look at commands that require you to give them something to work with.</strong></p>
<p>One such command is <code>cd</code>, for ‚Äòchange directory‚Äô. As you might have guessed, this command allows you to go to a different directory from your current one. In other words, that‚Äôs how you go from one folder to another. For example, try moving to one of your folders, like the Downloads one if you have one.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cd Downloads
</code></pre></div><p>This will make you go to your Downloads folder. If you just type <code>cd</code>, nothing will happen. You have to give it the directory you want to move into as an argument of the command (that is, <code>cd Downloads</code>). If you type in <code>pwd</code> now, you will see you are directory has indeed changed. Perhaps now it‚Äôs something like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"> ~/Downloads
</code></pre></div><p><code>~</code> refers to your home folder. So this means: You‚Äôre inside the <code>Downloads</code> folder, which is in your home folder. <code>~</code> is shorthand for whatever your home folder is because this might change (for example, you might change your username, which changes your home folder). <code>cd ~/Downloads</code> will therefore work regardless of this.</p>
<p>If you‚Äôre in <code>Downloads</code> and you want to go back one level you can type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cd ..
</code></pre></div><p>Which means going back (or up) one level.</p>
<p><code>mkdir</code> (short for ‚Äò<code>m</code>a<code>k</code>e <code>dir</code>ectory‚Äô) creates a directory (or folder). This command also takes in an argument, which is the name of the folder you want to create.</p>
<blockquote>
<p><strong>Practice:</strong> Let‚Äôs try it. Type in:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mkdir something
</code></pre></div><p>And now you will have a folder called <code>something</code> in your working directory.</p>
<blockquote>
<p><strong>Practice:</strong> You might as get in that folder, and then go back. How would you do that?</p>
</blockquote>
<p>By the way, this is a good time to tell you that you can get ‚Äúauto-complete‚Äù if you press the <code>tab</code> key. If you type <code>cd some</code> and then <code>tab</code>, you will see it completes to <code>something</code>, the folder you just created. This is works for commands, folders and files.</p>
<p><code>mv</code> moves a file. Similar to <code>cd</code> or <code>mkdir</code> in that, to use it, you only have to write <code>mv</code> followed by the file you want to move, but including as well the destination. For example, imagine you created a file called <code>list.txt</code> and you want to move it to the <code>something</code> folder you created before. That&rsquo;d be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mv list.txt something/
</code></pre></div><p><code>cp</code> copies a file. It&rsquo;s usage is similar to the previous example, except that it keep a copy of the file in the original place (just like <code>CTRL + c</code>, <code>CTRL +x</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cp file folder/file
</code></pre></div><p>You might have noticed that the folder is distinguished from a file by <code>/</code> at the end of the name.</p>
<blockquote>
<p><strong>Exercise:</strong> To discover a new use of <code>mv</code> try to do <code>mv</code> on a file, but instead of ending the second argument (the folder‚Äôs name) on <code>/</code> , write something without it (as in <code>mv lists.txt folder</code>). What happened?</p>
</blockquote>
<p>Let‚Äôs say you get into the <code>something</code> file and you want to delete your <code>list.txt</code>. To remove it, do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">rm list.txt
</code></pre></div><p>Mind that in the terminal there is no confirmation prompt for this action, and files aren&rsquo;t moved to the trash - they just disappear, meaning you have to be extra careful of what you delete in there.</p>
<p>What if you want to remove a folder, like the one you created before, <code>something/</code>? Try it in your terminal. You sould see something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">rm: cannot remove <span style="color:#e6db74">&#39;something&#39;</span>: Is a directory
</code></pre></div><p>The solution in cases like this is browsing the manual, perhaps the most usefool tool to learn to use any program in the terminal. Typing <code>man</code> and the name of the package you want to learn about opens the manual for that tool, including all the optional arguments of that tool.</p>
<blockquote>
<p><strong>Exercise:</strong> Enter <code>man rm</code> and browse the manual until you find the argument you have to provide to remove whole folders, and whatever is in them &ndash; a recursive removal. The structure is <code>rm </code>-<em>letter</em><code> folder</code>.</p>
</blockquote>
<p>So, to recapitulate:</p>
<ul>
<li><code>pwd</code> Prints the current (Working) Directory</li>
<li><code>ls</code> lists the files of a folder</li>
<li><code>cd</code>, accompanied of an argument, moves you to the specified folder</li>
<li><code>mkdir</code> plus an argument creates a folder with that name</li>
<li><code>cp</code> and <code>mv</code> copy and move files</li>
<li><code>rm</code> removes the file you specify as an argument</li>
<li><code>man</code> plus the name of a tool opens the manual of the tool. You should use it when you don&rsquo;t understand how a command works</li>
</ul>
<h1 id="some-easy-commands-to-begin-exploring-data">Some easy commands to begin exploring data</h1>
<p>Now we are going to check various ways of opening and manipulate files.</p>
<p><code>less</code> is the kind of utility you need to peek at very big files that can‚Äôt be processed normally. <code>less</code> produces a look of a screen a time, requiring almost no processing power to show you part of a file. It‚Äôs a great tool for all those +1gb files that you might have.</p>
<blockquote>
<p><strong>Exercise:</strong> Create or get a text file of any kind and put it in the folder you happen to be in right now (Or navigate your way to the file if you want to practice that!). Let‚Äôs imagine that file is called <code>myfile.txt</code>. Do:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">less myfile.txt
</code></pre></div><p>You will see however many lines fill up your screen, and you scroll down or press <code>Enter</code> to navigate your file.</p>
<p><code>wc</code> shows line, word and character count. You can specify one of these counts only with options, such as <code>wc -l</code>, which gives you only the line count.
| Try it in your <code>myfile.txt</code> file!</p>
<p><code>head</code> shows the first 10 lines of a file. With an option <code>-n</code>, you can define how many lines you want to see. Let‚Äôs say you have a file called <code>file.txt</code> with 10 lines: <code>one</code>, <code>two</code>, <code>three</code> and so on. Doing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">head -n <span style="color:#ae81ff">5</span> file.txt
    one
    two
    three
    four
    five
</code></pre></div><p>The command <code>tail</code> does the same, but with the last lines of a file, saving you some endless scrolling down.</p>
<p>Now imagine what you want is to compare two files for differences. <code>diff</code> does exactly that. To illustrate how it works, imagine you have two text files, <code>file1.txt</code> and <code>file2.txt</code>.</p>
<p><code>file1.txt</code> contains:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">    one
    two
    three
    four
</code></pre></div><p><code>file2.txt</code> contains:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">    one
    three
    five
    seven
</code></pre></div><p>If you do :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">    diff file1.txt file2.txt
</code></pre></div><p>you will get the differences between the two. There are different ways of outputting the result of this comparison. Option <code>-u</code>, for example, is a useful one. Doing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">diff -u file1.txt file2.txt
</code></pre></div><p>will give you:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">     one
    -two
     three
    -four
    +five
    +seven
</code></pre></div><p>Where lines with no symbol in front of them are in both files, lines with <code>-</code> are only in <code>file1.txt</code>, and lines with <code>+</code> are only in <code>file2.txt</code>.</p>
<blockquote>
<p><strong>Exercise:</strong> maybe you&rsquo;d like to learn other output formatting options. Why don&rsquo;t you check what the <code>-y</code> option does, for example?</p>
</blockquote>
<p><code>comm</code> also compares two files, but in a different way. It pays attention to the actual line (that is, not just what‚Äôs on the line, but which line is it), and gives you a column with the lines unique to <code>file1.txt</code>, lines unique to <code>file2.txt</code>, and lines common to both.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">comm file1.txt file2.txt
</code></pre></div><p>will give you:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">                    one
            three
            five
            seven
    two
    three
    four
</code></pre></div><p>Recapitulating:</p>
<ul>
<li><code>less</code> is a program that&rsquo;s really helpful to open plain text files, specially big ones</li>
<li><code>head</code> and <code>tail</code> give you the beginning and end of a file</li>
<li><code>comm</code> and <code>diff</code> are some of the programs you can use to compare files in different ways</li>
</ul>
<blockquote>
<p><strong>Exercise:</strong> delete the first line of <code>file2.txt</code> using only <code>tail</code> and arguments. Feel free to google the solution, or use only <code>man</code> for an extra challenge.</p>
</blockquote>
<p>There are many other programs that you could be using, but first we want to tell you a couple things that might ease your learning curve:</p>
<h2 id="general-notes-about-the-terminal-enviroment">General notes about the terminal enviroment</h2>
<ul>
<li>Pressing <code>‚Üë</code> (and <code>‚Üì</code> will allow you to go through the last commands you typed. This can be very useful if you make a typo or you want to modify slightly a command you gave to the terminal.</li>
</ul>
<blockquote>
<p><strong>Exercise:</strong> since you have already typed out some commands you can try this now in your terminal!</p>
</blockquote>
<ul>
<li>As we told you before, if you press <code>Tab</code>  the names of files or programs are filled. This saves enormous amounts of time and effort, specially for that file called <code>paper_version7_final_but_not_quite_yet.version2.withgenes.out.pdf</code> or whatever other silly name. If you have a folder with several files with similar names, as it will happen often, <code>Tab</code> will only complete until the first diverging character (<code>paper_version</code>, for example, if you have a <code>paper_version6</code>etc somewhere in the same folder. Try tapping <code>Tab</code>twice to see all the files named <code>paper_version</code>+whatever.</li>
<li>Mind that <strong>copy-pasting</strong> behavior in terminals changes depending on the operative system: in some Linux distributions, for example, the usual shortcut for copying (<code>Ctrl + c</code>) is changed to <code>Ctrl + Shift + c</code>.</li>
<li>You don‚Äôt have to list all files that you are applying a utility to. You can use wildcarding with *, as in <code>mv paper_version* afolder/</code>, that would move all files called <code>paper_version</code> plus whatever to  <code>afolder/</code>.</li>
</ul>
<blockquote>
<p><strong>Exercise:</strong> remember when we gave you an example of an script early on? try creating some files with <code>test</code> in the name and others without it and deleting only the ones with <code>test</code> in their names from the terminal.<br>
<strong>Question:</strong> what would <code>sort *.txt</code> do? Try it out, checking the <code>man</code>ual page of <code>sort</code> before if you prefer.</p>
</blockquote>
<ul>
<li>Avoid whitespaces in names of files and folders. Whitespaces are usually handled by terminals, but they are likely to give you problems in the long term if you want to bulk-process files, so in general it‚Äôs good practice to not use them just in case. Underscores <code>_</code>  are a good substitute.</li>
<li>You can stop works at any point with <code>Ctrl + z</code>. Mind that the program will continue running in the background, with the consequent drop in performance if you tried to process something heavy enough. <code>ctrl + c</code> will usually abort the running process.</li>
<li>To absolutely kill a process after trowing it to the background, try <code>jobs</code>, see what number the process you want to kill has, and then use <code>kill %number</code> (as in <code>kill %3</code>). If you‚Äôd rather bring a process to the foreground, use <code>fg %number</code>.</li>
<li>If you need a full account of all the commands you have pressed (to, for example, trace back your steps and see where you messed up something) type <code>history</code>.</li>
</ul>
<h3 id="redirecting-output">Redirecting output</h3>
<p>So far all these commands have produced output that is printed, if done correctly, in your terminal. But what if you want to have a file with the results of a command?
That&rsquo;s what the output redirection in for. You can redirect the printed output of any command with <code>&gt;</code>. For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">comm file1.txt file2.txt &gt; result.txt
</code></pre></div><p>will generate a new file called <code>result.txt</code> with the results we showed you above.
You also have the option of providing input for a command with <code>&lt;</code> and appending the output of a command to a file with <code>&gt;&gt;</code>.</p>
<blockquote>
<p><strong>Exercise:</strong> Try appending the result of <code>diff</code> to the same <code>result.txt</code> file now, and examine it with <code>less</code> or <code>head</code>/<code>tail</code></p>
</blockquote>
<blockquote>
<p><strong>Exercise:</strong> Imagine you have to know how many files and folders are there in your desktop. How would you do it with two of the commands we have show you already? Generate a file with that list.</p>
</blockquote>
<h3 id="pipes">Pipes</h3>
<p>Most of these utilities produce mutually intelligible outputs. That means you can concatenate their outputs, multiplying their efficiency, using <code>|</code>. This is one of the most useful features of the Unix shell.</p>
<blockquote>
<p><strong>Exercise:</strong> Try to understand what the following pipeline does. Use <code>man</code> if necessary:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"> sort *.txt | uniq -c | sort -nr &gt; all.txt
</code></pre></div><blockquote>
<p><strong>Question:</strong> Why did we use <code>sort</code> twice here?</p>
</blockquote>
<p>Remember when we spoke about <strong>one-lines</strong>? This is how many of them are written: combining command-line programs with specific options in innovative ways that solve a very specific kind of problem.</p>
<p>If you know any programming language, think about how would you do the same task and compare it to this code. While it&rsquo;s not always the case, some of these programs are way quicker and shorter than their equivalents in, for example, Python.</p>
<p>Recapitulating:</p>
<ul>
<li>Pipes are useful to concatenate operations</li>
<li>You can redirect command outputs to files</li>
<li>Remember to use <code>tab</code> and <code>‚Üë</code>/<code>‚Üì</code> to your advantage</li>
</ul>
<h1 id="a-step-up-grep-sed-awk-and-using-regex">A step up: grep, sed, awk and using regex</h1>
<p>So far we have seen various programs, but you&rsquo;ll notice some of the most useful programs aren&rsquo;t here. Here are three extremely powerful tools for text/data manipulation: <code>grep</code>, <code>sed</code>and <code>awk</code>. They all can profit from a formal string-searching language invented in the 50s called <code>regex</code>, so let&rsquo;s start with that.</p>
<h2 id="regex">Regex</h2>
<p>Regex stands for <strong>regular expression</strong> (as in an expression that describes a regular language in the Chomsky hierarchy sense, which is a piece of information that might help you or confuse you further). Using regex allows to capture <em>patterns</em> of characters instead of literal strings. Regex are very pervasive and you might cross them in some programming languages, such as Python.</p>
<p>Arguably, writing regex is not the most intuitive task out there, but with some practice one gets the hang of it (like <code>^.\d*$</code>, which, of course, would capture all lines starting (<code>^</code>) with any one character <code>.</code> followed by any number <code>*</code> of <code>\d</code>igits (so, <code>\d*</code>), followed by a line end  <code>$</code>. Luckily for you, you only have to know a handful of these expressions for regular work, and there‚Äôs a number of  <a href="https://www.rexegg.com/regex-quickstart.html" target="_blank">cheatsheets</a> out there to help you. The rigidity of Regex, however, is great for all sorts of problems. Let‚Äôs imagine you have the following file, called <code>patterns.txt</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">    <span style="color:#ae81ff">1</span>
    <span style="color:#ae81ff">123</span>
    <span style="color:#ae81ff">123</span> <span style="color:#ae81ff">123</span>
    a
    abc
    abc <span style="color:#ae81ff">123</span>
    a123
</code></pre></div><blockquote>
<p><strong>Question:</strong> Which of these lines would be captured by the regex we used as an example (<code>^.\d*$</code>)?</p>
</blockquote>
<p>Let‚Äôs go over it again:</p>
<ul>
<li><code>^</code> means start of the line</li>
<li><code>.</code> means any one character</li>
<li><code>\d</code> means digit</li>
<li><code>*</code> is a quantifier which means any number of characters (including 0) of the kind just defined (in this case, digits)</li>
<li><code>$</code> means end of line</li>
</ul>
<p>Let‚Äôs see what would be captured:</p>
<ul>
<li><code>1</code> is captured. It starts the line, we have a character (<code>1</code>), we then have 0 digits, and then the line ends.</li>
<li><code>123</code> is captured. It starts the line, then we have a character (<code>1</code>), we then have 2 digits (<code>23</code>), and then the line ends.</li>
<li><code>123 123</code> is <strong>not</strong> captured. It starts the line, we then have a character (<code>1</code>), also some digits (<code>23</code>), but then we have a space. A space is not a digit. This one is out.</li>
<li><code>a</code> is captured. It starts the line, we have a character (<code>a</code>), we then have 0 digits, and then the line ends.</li>
<li><code>abc</code> is <strong>not</strong> captured. It starts the line, we then have a character (<code>a</code>), but it‚Äôs not followed by a number of digits. If we consider that the number of digits is 0, we would then expect the line to end, but we have some letters instead (<code>bc</code>).</li>
<li><code>a123</code> is captured. It starts the line, we then have a character (<code>a</code>), followed by 3 digits (<code>123</code>), and then the line ends.</li>
</ul>
<p>We can check this quickly on our file by using one of the most powerful Unix tools out there: <code>grep</code>. <code>grep</code> allows regex input, such as <code>^.\d*$</code>, and can be used to capture all lines in our <code>patterns.txt</code> file matching these.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">grep <span style="color:#e6db74">&#39;^.\d*$&#39;</span> patterns.txt
</code></pre></div><p>The result should be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">123</span>
a
a123
</code></pre></div><p>There are at least two syntax versions of Regex: one built for the Perl programming language, which is the one we have been using, and another called POSIX (which is arguably more transparent). You have to be careful with this when writing regular expressions.</p>
<p>To ensure that your version of <code>grep</code> uses Perl-like regex you can always use the <code>-P</code> option. Sometimes solutions will be easier to memorize in a particular Regex syntax, but this isn&rsquo;t usually a problem, since you&rsquo;ll probably not memorize the dozens of options available anyway.</p>
<h2 id="grep">Grep</h2>
<p>As we have introduced just before, <code>grep</code> is a great terminal utility used for finding strings in a file. Imagine having to perform a search through a series of <code>.csv</code> documents for a specific string, let‚Äôs say <code>FOXP2</code>. You could do something like <code>grep FOXP2 *.csv</code>. One of the beauties of <code>grep</code> is that it can also search by regular expressions, among many other options that make it an extremely useful tool.</p>
<p>Let‚Äôs check, for example, one of the most handy options: <code>grep -f</code>, or <code>fgrep</code>. <code>fgrep</code> takes as input a plain text documents and performs <code>grep</code> on the second argument files through each one of the input file lines.
Imagine the following document with four gene names, called <code>input</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">    FOXP2
    FOXP1
    AMIGO
    EDAR
</code></pre></div><p>A line like <code>fgrep input *.txt &gt; output</code> will produce a new file, called output, that is the result of all the instances where grep has found any of these terms in any of the working directory‚Äôs <code>.txt</code> files.</p>
<blockquote>
<p><strong>Exercise:</strong> check your <code>history</code> for all the times you have used <code>rm</code> (or some other terminal program).
<strong>Exercise:</strong> how many times have you used each command so far?</p>
</blockquote>
<blockquote>
<p><strong>Exercse:</strong> Try searching for &ldquo;FOX&rdquo; in a file with those contents with <code>grep</code>. What happened. Now try with <code>grep -w</code>. What does <code>-w</code> stand for and why should you remember this always?</p>
</blockquote>
<h2 id="sed">Sed</h2>
<p>Sed filters and processes text. Sed can, for example, substitute (<code>s/</code>) any given matched string by whatever you want in a large quantity of files without a sweat, and it‚Äôs its more common usage. Sed has many options, but regularly <code>/</code> delimits the fields and options. Sed has several flags, such as <code>/g</code> (global), which point at how many replacements should <code>sed</code> do (in this case, all possible).</p>
<blockquote>
<p><strong>Question</strong>: what does <code>sed 's/freqeunt/frequent/g' *.txt</code> do?</p>
</blockquote>
<blockquote>
<p><strong>Exercise:</strong> think about an instance where <code>sed</code> would have saved you time in a task!</p>
</blockquote>
<blockquote>
<p><strong>Exercise:</strong> Sed also accepts regex. How would you transform a comma sepparated <code>.csv</code> into a tab separated <code>.tsv</code>? Tip: to scape a character so that it&rsquo;s not interpreted as a regular expression, you have to precede it by , like <code>grep -P &quot;stringfollowedby\?&quot;</code>.</p>
</blockquote>
<p>You can specify multiple orders with sed, like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">sed <span style="color:#e6db74">&#39;s/freqeunt/frequent/g ; s/typo/typpo/g&#39;</span> *.txt &gt; resultfile.txt 
</code></pre></div><p>Sed is great, but the documentation in known to be a <strong>mess</strong>, so most people stick with the &rsquo;s/' option, arguably the most useful one. However, if you are extra motivated, we encourage you to learn other uses. Particularly, we recommend  <a href="https://www.grymoire.com/Unix/Sed.html" target="_blank">this comprehensive guide</a>. Ever wondered how to, for example, erase all the instances of a particular word in a text? I haven&rsquo;t, but you can learn how there.</p>
<h2 id="awk">Awk</h2>
<p>Awk is, well, <strong>awkfully</strong> ugly to write, specially compared to the modern standard of programming, but also a very powerful tool (and actually it&rsquo;s own programming language!). Awk is specialized on column-type data. Imagine you had a file like this and you wanted to get every item in column <code>chrom</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e">#Snp chrom position feature</span>
rs1892 <span style="color:#ae81ff">12</span> <span style="color:#ae81ff">1233455</span> Something
rs1980802 <span style="color:#ae81ff">12</span> <span style="color:#ae81ff">1233470</span> Somethingelse
rs1123213 <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">2333455</span> Nothing
</code></pre></div><p>You could do an error-prone, hacky solution with <code>grep</code>, or import it to python and use <code>pandas</code>, but you&rsquo;d be surprised how many times <code>awk</code> can be more convenient than those options.</p>
<p>Essentially, awk works this way: <code>awk '(conditions, if any){any order}' inputfile</code>. So, if you wanted to get columns two and three out of the example file provided above, you could like it this way:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">awk <span style="color:#e6db74">&#39;{print $2, $3}&#39;</span> examplefile
</code></pre></div><p>Note several things: what you want to do is enclosed in <code>'</code>, and then subcommands can be enclosed in <code>{round brackets}</code>. Awk is its own beast and we can&rsquo;t cover it in extent (there are  <a href="https://ia802309.us.archive.org/25/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf" target="_blank">books for that</a>, but you should know it is so useful that there&rsquo;s a flavour of it specifically for genetics data,  <a href="https://bioinformaticsworkbook.org/Appendix/Unix/bioawk-basics.html" target="_blank">bioawk</a>. As long as you data is more or less tidy, awk is still something worth learning. I&rsquo;ve heard people swear by it and seen whole programs to do the same things that people use python for nowadays. You don&rsquo;t have to get to that extreme, but there&rsquo;s a reason some people do that: don&rsquo;t underestimate awk.</p>
<p>As a full-fledged programming language, awk also has <code>if</code> conditionals, for example. Here&rsquo;s a recent example I used in my work:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">awk <span style="color:#e6db74">&#39;{if ($3==$4) print $0, FILENAME}&#39;</span> *.csv
</code></pre></div><p>What this does is, it checkes if columns 3 and 4 have the same content in each file, and then print the whole row when the condition is met (that&rsquo;s what <code>$0</code> means} and the filename (literally, <code>FILENAME</code>). This is of course a bit trivial, but it can get way trickier than this, such as checking whether two columns are the same in two files and creating a new file with some of the contents of the first file when there&rsquo;s a column match from the values of the second file (convoluted, yes, but a  <a href="https://stackoverflow.com/questions/18592736/awk-compare-columns-from-two-files-impute-values-of-another-column" target="_blank">very</a>  <a href="https://stackoverflow.com/questions/64139198/awk-compare-two-columns-form-different-files-and-merge-outputs" target="_blank">common</a>  <a href="https://stackoverflow.com/questions/18592736/awk-compare-columns-from-two-files-impute-values-of-another-column" target="_blank">problem</a> at which awk excels).</p>
<p>Ammong other things it can do, awk accepts regex as well. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">awk <span style="color:#e6db74">&#39;/pattern/{ print $0 }&#39;</span> file.txt
</code></pre></div><blockquote>
<p><strong>Question</strong>: how would you get column 1 in a file like the one we showed at the beginning of this section without using awk, i. e. using tools that have been already explained here? Tip: you are allowed to check regex cheatsheets.</p>
</blockquote>
<blockquote>
<p><strong>Exercise:</strong> Think about some of the tools you use to manipulate and extract data. How could you integrate awk in your day-to-day work? Why don&rsquo;t you try to extract a column or two of interest to a new file in your prefered tool and compare it with what you just learned?</p>
</blockquote>
<h1 id="a-last-word-sudo">A last word: sudo</h1>
<p><code>sudo</code> is the basic command to assume the root or superuser role, meaning it gives you permission to do things that require certain privileges. It is implemented so that not anyone can do certain actions in a computer that might be harmful for it if you are not the administrator.
When something requires this role, you will be asked for you password. Type it in and press Enter (note: you will not see the password or asterisks show up in your screen).</p>
<p>You might be shown an error or ‚Äúpermission denied‚Äù message when trying certain operations. Try them out with <code>sudo</code> and you should be ok. For example, depending on where you are in your filesystem, you might only be able to create new directories by doing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">sudo mkdir myfolder
</code></pre></div><p>and then typing your password.</p>
<h2 id="installing-new-programs">Installing new programs:</h2>
<p>The easiest way to install new terminal programs is by using a package manager. Package managers allow you to keep your system up-to-date by upgrading existing software, as well as install new software.</p>
<h3 id="linux">Linux</h3>
<p>Different Linux distributions come with different package managers. A common one is apt, which comes with Debian-based distributions, such as Ubuntu, a popular distribution for Linux beginners. There are other package managers out there such as <code>snap</code> that we won&rsquo;t cover here, but that work similarly.</p>
<p>To keep your system up-to-date, you do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">sudo apt-get update
</code></pre></div><p>This updates the sources from which the software can be upgraded. It signals your computer ‚Äúhere‚Äôs how you get the new stuff!‚Äù.</p>
<p>You can then do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">sudo apt-get upgrade
</code></pre></div><p>And this will actually upgrade the programs you currently have installed.</p>
<p>To install a new package, you just need the name of the program you want to install (for example, pandoc) and do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">sudo apt-get install pandoc
</code></pre></div><p>And after installation you will be able to use pandoc commands. If you do exactly as instructed and you get a command not found message, chances are you simply need to install that program.</p>
<h3 id="macos">MacOs</h3>
<p>MacOS does not come with a package manager pre-installed, because the large majority of Mac users does not use the terminal (the same cannot be said of Linux users). A popular one is Homebrew. Go to the Homebrew website and follow the  <a href="https://brew.sh" target="_blank">installation instructions</a>, which amount to pasting a line of code into the terminal.</p>
<p>The process is similar to what we explained before, but with some differences. The first one is that you do not need special permissions (so no sudo)</p>
<p>The update your system, do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">brew update
</code></pre></div><p>and then:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">brew upgrade
</code></pre></div><p>To install a program (say, pandoc) do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">brew install pandoc.
</code></pre></div><h1 id="connection-to-remote-machines">Connection to remote machines</h1>
<p>Sometimes, especially if you work with large amounts of data or perform heavy computations, you need to connect to a remote machine. A common way to do so is by using the <code>ssh</code> protocol (short for <code>s</code>ecure <code>sh</code>ell), which is most often used through the terminal. To do so, you need to know the IP address, username and password of the computer you are going to connect to (if you need to connect to a remote machine to do your work, you were probably provided this information). If the remote machin&rsquo;s username is <code>user</code> and the IP address is <code>192.168.2.100</code>, all you need to do is:</p>
<p><code>ssh username@192.168.2.100</code></p>
<p>You will the be prompted to type in the password, and you will be in. Once in, you will have access to the files and programs that user would have locally, as if you had opened a terminal in that remote machine. The things you‚Äôve learned so far in this course should give you a leg up should you find yourself in this situation.</p>
<p>Some people even use computers that have no screen attached to them, and access them by connecting remotely through <code>ssh</code>. The Raspberry Pi, for example, is a popular example of this. Some people have one hiding away somewhere in their home, doing something cool, undisturbed, connected to the internet but with no screen, keyboard or mouse attached. Whenever they need to check up on it, they just ‚Äú<code>ssh</code> into it‚Äù from another computer in the house or the internet.</p>
<h1 id="the-end">The end</h1>
<p>Congrats, you have finished our quick course! Here&rsquo;s your prize:  <a href="https://github.com/mtoyoda/sl" target="_blank">an ASCII train</a></p>
<figure>
    <img src="pics/serious.png" width="680" height="453" style="vertical-align:middle">
</figure>
<p>If you know your basics of shell, maybe you&rsquo;d enjoy my other post on  <a href="https://andirko.eu/post/cli_tips/" target="_blank">tools and good practices in bash I&#39;ve been experimenting with lately</a>, and if you want to learn LaTex, Pedro has an amazing  <a href="http://ptmartins.info/latex/" target="_blank">guide</a> essential for every beginner (I personally learned LaTex almost entirely using it!).</p>
<hr>
<p>We hope this course was useful for you! Did you find an error, an annoying typo or want to provide feedback? Please drop me a mail at <a href="mailto:munoz.andirko@ub.edu">munoz.andirko@ub.edu</a></p>

</div>

        </div>
    <div id="footer">
        <hr>
        <div class="container text-center mb-2">
            <a href="https://andirko.eu"><small>Last updated: 12/04/2021 </small></a>
        </div>
    </div>

</body>
</html>
